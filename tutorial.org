#+STARTUP: beamer
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [10pt, t]
#+BEAMER_FRAME_LEVEL: 1
#+TITLE: Collaborative Coding: Developing DESC Software
#+AUTHOR: Jim Chiang
#+DATE: 2016-03-08
#+COLUMNS: %45ITEM %10BEAMER_env(Env) %8BEAMER_envargs(Env Args) %4BEAMER_col(Col) %8BEAMER_extra(Extra)
#+PROPERTY: BEAMER_col_ALL 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 :ETC
#+OPTIONS: toc:nil
#+LaTeX_HEADER: \newcommand{\code}[1]{{\tt{#1}}}
#+LaTeX_HEADER: \newcommand{\mybold}[1]{{\textbf{#1}}}
#+LaTeX_HEADER: \hypersetup{colorlinks=true, urlcolor=blue}

* Outline
- Key Messages:
  - Automate your tests.
  - Read other people's code, have others look at yours.
  - Have a set of coding conventions for your group.
- Demos:
  - GitHub flow
  - Using a testing framework other development tools
  - Travis CI

Reference material: [[https://confluence.slac.stanford.edu/x/RA1lD]]

* Automate Your Tests
  \mybold{Why:}
  - Everyone who runs their code and looks at the output is testing
    their code.
  - If you want others to use your code or rely on the results from
    your code, it needs to be tested systematically.
  - Even for well-designed, loosely coupled code, new development can
    introduce bugs that break existing functionality.  A good set of
    automated tests can guard against that.

* Automate Your Tests
  \mybold{How:} There are many types of softare testing: system,
  integration, regression, etc..  \emph{Unit tests} bear most directly
  on day-to-day (or even minute-to-minute) development.
  - Unit tests exercise the functionality of the smallest units of
    code (functions and class methods).  They should be "atomic" and
    isolated (i.e.., have few external dependencies).
  - It is natural to test for success, i.e., compare results to
    expectations, but one should also check for failure, e.g.,
    raising exceptions for bad input, etc..
  - Unit tests should be quick and easy to execute, and they should be
    run often throughout the development cycle.
  - The output of successful tests should be minimal.  If you have to
    examine the output to verify success, you will run the tests less
    often.
  - Consider using "test first development" methods, especially for
    fixing bugs: write a test that reveals the bug, fix the code to
    make it pass, and keep that test as part of the test suite.
  - Use a testing framework, e.g., \code{unittest} for Python, and
    hook it up to a continuous integration system like Travis CI or
    Jenkins.

* Read other people's code, have others read yours
  \mybold{Why:}
  - Software development has standard practices and tools that have
    evolved which help make code more reliable.  Those practices can
    be taught, but most scientists pick up coding on their own and not
    necessarily with the best examples at hand.  Learn from and teach
    others.
  - Not everyone approaches a coding task the same way.  Multiple eyes
    on a problem or design issue can lead to better implementation.
  - For a group software project, there is a lot of risk in having
    only one person who understands or can maintain an important part
    of the code base.  The more widely understood an important code
    is, the better.

* Read other people's code, have others read yours
  \mybold{How} -- some suggestions:
  - Share your code on GitHub.  This is the easiest way to make your code
    available for other to read and try out.
  - Do code reviews.  If done incrementally, reviews can be relatively
    painless.
  - Pair program.  Have people with different programming backgrounds and
    different levels of experience work together.
  - Have different people cycle through working on any given part of
    the code.  This will help ensure that the expertise to work
    effectively on any part of the codebase does not reside in just
    one person.

* Have a set of coding conventions for your group
  \mybold{Why:} Coding style is like a dialect: two developers may be
  using the same language (Python, C++), but if their respective
  coding styles differ substantially, they'll have trouble
  understanding each other's code.

* Have a set of coding conventions for your group
  \mybold{How} -- suggestions:
  - Look at standard conventions, such as [[https://www.python.org/dev/peps/pep-0008/][PEP8]], which are standards
    for a reason.  Reach consensus on the standards that you do adopt.
  - Use code checking tools, such as \emph{linters} like [[https://www.pylint.org/][PyLint]].
    These are configurable and can also perform static code analysis
    to uncover real or potential bugs.
  - Use editor plugins for the code checking tools so that the friction
    to using them is minimal.
  Another benefit of having code pass linter-type tests is that a person
  reviewing the code can concentrate on the substantive features of the
  implementation, thereby making the feedback from the review more
  valuable.

* GitHub Flow
  For a project with several developers, it is helpful to have a common
  \emph{development workflow} to avoid conflicts.  Git's branching facility
  is a powerful feature which enables this.  There are a number of different
  workflows that are widely used.  The DM team's workflow is a slight variant
  of GitHub Flow.

  Here are the steps for [[https://guides.github.com/introduction/flow/][GitHub Flow]]:
  - Create a branch off master.  The key point here is that master should
    always be deployable, i.e., not broken.
#+BEGIN_SRC sh
   $ git branch
   * master
   $ git checkout -b issue/3/neg_nums_not_prime
   Switched to a new branch 'issue/3/neg_nums_not_prime'
   $
#+END_SRC sh

* GitHub Flow (2)
  - Add commits to keep track of the work done on the branch.
#+BEGIN_SRC sh
   $ emacs tests/test_Primes.py

   <...edit the test code...>

   $ git add tests/test_Primes.py
   $ git commit -m "add test for negative numbers"
   [issue/3/neg_nums_not_prime ae7310c] add test for negative numbers
    1 file changed, 4 insertions(+)

   <...edit the production code...>

   $ git add python/desc/primes/Primes.py 
   $ git commit -m "fix Primes.is_prime to handle negative numbers correctly"
   [issue/3/neg_nums_not_prime 7f1a26d] fix Primes.is_prime to handle negative numbers correctly
    1 file changed, 1 insertion(+), 1 deletion(-)
   $
#+END_SRC sh

* GitHub Flow (3)
  - Push the changes to GitHub.
#+BEGIN_SRC sh
   $ git push -u origin issue/3/neg_nums_not_prime 
   Counting objects: 21, done.
   Delta compression using up to 4 threads.
   Compressing objects: 100% (11/11), done.
   Writing objects: 100% (14/14), 1.22 KiB | 0 bytes/s, done.
   Total 14 (delta 6), reused 0 (delta 0)
   To git@github.com:jchiang87/my_Primes.git
    * [new branch]      issue/3/neg_nums_not_prime -> issue/3/neg_nums_not_prime
   Branch issue/3/neg_nums_not_prime set up to track remote branch issue/3/neg_nums_not_prime from origin.
   $
#+END_SRC sh

* GitHub Flow (4)
  - Open a Pull Request.  This can happen at any time and provides a
    forum for the discussion about the development, including code review.
    Continuous integration tools like Travis CI can be configured to
    trigger builds on pushes or PRs.
  - Discuss and review the code using the PR thread.  Make any changes
    in response to the review, and commit and push to the branch as
    before.
  - Once all the tests pass and the reviewer is satisfied, merge into
    master.  There may be a step to run and pass \emph{integration
    tests} before merging into master; these could also be triggerable
    as part of the CI service.

* Demo using development tools with \code{emacs}
  Some relevant links:
  - [[https://docs.python.org/2/library/unittest.html][unittest]]: The standard unit testing framework for Python.
  - [[https://www.pylint.org/][PyLint]]: A Python code checking tool.
  - [[https://nose.readthedocs.org/en/latest/][nose]]: For running unit tests.
  - [[http://jedi.jedidjah.ch/en/latest/][Jedi]]: An autocompletion and static analysis library for Python.
  - DM team configurations for [[http://developer.lsst.io/en/latest/tools/emacs.html][emacs]] and [[http://developer.lsst.io/en/latest/tools/vim.html][vim]].

* Demo using Travis CI
  Be sure to use the \code{.org} address for \emph{public} GitHub 
  repositories:
  https://travis-ci.org/

* Summary
- Take-aways:
  - Automate your tests.
  - Read other people's code, have others look at yours.
  - Have a set of coding conventions for your group.
- Demos:
  - GitHub flow
  - Using a testing framework and tool usage
  - Travis CI

Reference material: \url{https://confluence.slac.stanford.edu/x/RA1lD}

